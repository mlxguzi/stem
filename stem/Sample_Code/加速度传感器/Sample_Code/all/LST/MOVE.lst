C51 COMPILER V9.54   MOVE                                                                  06/26/2018 11:27:10 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MOVE
OBJECT MODULE PLACED IN .\Output\MOVE.obj
COMPILER INVOKED BY: E:\keil\C51\BIN\C51.EXE ..\..\Common\MOVE.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\..\Common;..\..\Incl
                    -ude) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\MOVE.lst) TABS(2) OBJECT(.\Output\MOVE.obj)

line level    source

   1          #include "buzzer.h"
   2          #include "SFR_Macro.h"
   3          #include "Function_define.h"
   4          #include "N76E003.h"
   5          #include "Common.h"
   6          #include "MOVE.h"
   7          #include "intrins.h"
   8          
   9          //**************************************************************************************************
  10          //定义类型及变量
  11          //**************************************************************************************************
  12          uchar dis[6];         //显示数字(-511至512)的字符数组
  13          int dis_data;         //变量
  14          
  15          
  16          //********************************************************************************
  17          //整数转字符串
  18          //********************************************************************************
  19          void lcd_printf(uchar *s,int temp_data)
  20          {
  21   1        if(temp_data<0)
  22   1        {
  23   2          temp_data=-temp_data;
  24   2          *s='-';
  25   2        }
  26   1        else *s=' ';
  27   1      
  28   1        *++s =temp_data/10000+0x30;
  29   1        temp_data=temp_data%10000;     //取余运算
  30   1      
  31   1        *++s =temp_data/1000+0x30;
  32   1        temp_data=temp_data%1000;     //取余运算
  33   1      
  34   1        *++s =temp_data/100+0x30;
  35   1        temp_data=temp_data%100;     //取余运算
  36   1        *++s =temp_data/10+0x30;
  37   1        temp_data=temp_data%10;      //取余运算
  38   1        *++s =temp_data+0x30;   
  39   1      }
  40          
  41          //******************************************************************************************************
  42          //串口初始化
  43          //*******************************************************************************************************
  44          void init_uart()
  45          {
  46   1        TMOD=0x21;        
  47   1      //  TH1=0xfd;   //实现波特率9600（系统时钟11.0592MHZ）    
  48   1      InitialUART0_Timer1(9600);
  49   1        TL1=0xfd;   
  50   1          
  51   1        SCON=0x50;
  52   1        PS=1;      //串口中断设为高优先级别
  53   1        TR0=1;     //启动定时器     
  54   1        TR1=1;
C51 COMPILER V9.54   MOVE                                                                  06/26/2018 11:27:10 PAGE 2   

  55   1        ET0=1;     //打开定时器0中断      
  56   1        ES=1; 
  57   1        EA=1;
  58   1      }
  59          
  60          //*************************************************************************************************
  61          //串口发送函数
  62          //*************************************************************************************************
  63          void  SeriPushSend(uchar send_data)
  64          {
  65   1      ///////////// 
  66   1        TI = 0;
  67   1      //////////////
  68   1          SBUF=send_data;  
  69   1        while(!TI);TI=0;    
  70   1      }
  71          //*************************************************************************************************
  72          //************************************延时*********************************************************
  73          //*************************************************************************************************
  74          void delay(unsigned int k)  
  75          {           
  76   1        unsigned int i,j;       
  77   1        for(i=0;i<k;i++)
  78   1        {     
  79   2          for(j=0;j<121;j++);
  80   2        }           
  81   1      }
  82          
  83          void Delay5us()
  84          {
  85   1        _nop_();_nop_();_nop_();_nop_();
  86   1        _nop_();_nop_();_nop_();_nop_();
  87   1        _nop_();_nop_();_nop_();_nop_();
  88   1        _nop_();_nop_();_nop_();_nop_();
  89   1        _nop_();_nop_();_nop_();_nop_();
  90   1        _nop_();_nop_();_nop_();_nop_();
  91   1        _nop_();_nop_();_nop_();_nop_();
  92   1        _nop_();_nop_();_nop_();_nop_();
  93   1        _nop_();_nop_();_nop_();_nop_();
  94   1        _nop_();_nop_();_nop_();_nop_();
  95   1        _nop_();_nop_();_nop_();_nop_();
  96   1        _nop_();_nop_();_nop_();_nop_();
  97   1        _nop_();_nop_();_nop_();_nop_();
  98   1        _nop_();_nop_();_nop_();_nop_();
  99   1        _nop_();_nop_();_nop_();_nop_();
 100   1        _nop_();_nop_();_nop_();_nop_();
 101   1        _nop_();_nop_();_nop_();_nop_();
 102   1      
 103   1      }
 104          //*************************************************************************************************
 105          //I2C起始信号
 106          //*************************************************************************************************
 107          void I2C_Start()
 108          {
 109   1          SDA = 1;                    //拉高数据线
 110   1          SCL = 1;                    //拉高时钟线
 111   1          Delay5us();                 //延时
 112   1          SDA = 0;                    //产生下降沿
 113   1          Delay5us();                 //延时
 114   1          SCL = 0;                    //拉低时钟线
 115   1      }
 116          //*************************************************************************************************
C51 COMPILER V9.54   MOVE                                                                  06/26/2018 11:27:10 PAGE 3   

 117          //I2C停止信号
 118          //*************************************************************************************************
 119          void I2C_Stop()
 120          {
 121   1          SDA = 0;                    //拉低数据线
 122   1          SCL = 1;                    //拉高时钟线
 123   1          Delay5us();                 //延时
 124   1          SDA = 1;                    //产生上升沿
 125   1          Delay5us();                 //延时
 126   1      }
 127          //**************************************************************************************************
 128          //I2C发送应答信号
 129          //入口参数:ack (0:ACK 1:NAK)
 130          //**************************************************************************************************
 131          void I2C_SendACK(bit ack)
 132          {
 133   1          SDA = ack;                  //写应答信号
 134   1          SCL = 1;                    //拉高时钟线
 135   1          Delay5us();                 //延时
 136   1          SCL = 0;                    //拉低时钟线
 137   1          Delay5us();                 //延时
 138   1      }
 139          //****************************************************************************************************
 140          //I2C接收应答信号
 141          //****************************************************************************************************
 142          bit I2C_RecvACK()
 143          {
 144   1          SCL = 1;                    //拉高时钟线
 145   1          Delay5us();                 //延时
 146   1          CY = SDA;                   //读应答信号
 147   1          SCL = 0;                    //拉低时钟线
 148   1          Delay5us();                 //延时
 149   1          return CY;
 150   1      }
 151          //*****************************************************************************************************
 152          //向I2C总线发送一个字节数据
 153          //*****************************************************************************************************
 154          void I2C_SendByte(uchar dat)
 155          {
 156   1          uchar i;
 157   1          for (i=0; i<8; i++)         //8位计数器
 158   1          {
 159   2              dat <<= 1;              //移出数据的最高位
 160   2              SDA = CY;               //送数据口
 161   2              SCL = 1;                //拉高时钟线
 162   2              Delay5us();             //延时
 163   2              SCL = 0;                //拉低时钟线
 164   2              Delay5us();             //延时
 165   2          }
 166   1          I2C_RecvACK();
 167   1      }
 168          //*****************************************************************************************************
 169          //从I2C总线接收一个字节数据
 170          //******************************************************************************************************
 171          uchar I2C_RecvByte()
 172          {
 173   1          uchar i;
 174   1          uchar dat = 0;
 175   1          SDA = 1;                    //使能内部上拉,准备读取数据,
 176   1          for (i=0; i<8; i++)         //8位计数器
 177   1          {
 178   2              dat <<= 1;
C51 COMPILER V9.54   MOVE                                                                  06/26/2018 11:27:10 PAGE 4   

 179   2              SCL = 1;                //拉高时钟线
 180   2              Delay5us();             //延时
 181   2              dat |= SDA;             //读数据               
 182   2              SCL = 0;                //拉低时钟线
 183   2              Delay5us();             //延时
 184   2          }
 185   1          return dat;
 186   1      }
 187          //*****************************************************************************************************
 188          //向I2C设备写入一个字节数据
 189          //*****************************************************************************************************
 190          void Single_WriteI2C(uchar REG_Address,uchar REG_data)
 191          {
 192   1          I2C_Start();                  //起始信号
 193   1          I2C_SendByte(SlaveAddress);   //发送设备地址+写信号
 194   1          I2C_SendByte(REG_Address);    //内部寄存器地址，
 195   1          I2C_SendByte(REG_data);       //内部寄存器数据，
 196   1          I2C_Stop();                   //发送停止信号
 197   1      }
 198          //*******************************************************************************************************
 199          //从I2C设备读取一个字节数据
 200          //*******************************************************************************************************
 201          uchar Single_ReadI2C(uchar REG_Address)
 202          {
 203   1        uchar REG_data;
 204   1        I2C_Start();                   //起始信号
 205   1        I2C_SendByte(SlaveAddress);    //发送设备地址+写信号
 206   1        I2C_SendByte(REG_Address);     //发送存储单元地址，从0开始  
 207   1        I2C_Start();                   //起始信号
 208   1        I2C_SendByte(SlaveAddress+1);  //发送设备地址+读信号
 209   1        REG_data=I2C_RecvByte();       //读出寄存器数据
 210   1        I2C_SendACK(1);                //接收应答信号
 211   1        I2C_Stop();                    //停止信号
 212   1        return REG_data;
 213   1      }
 214          //******************************************************************************************************
 215          //初始化MPU6050
 216          //******************************************************************************************************
 217          void InitMPU6050()
 218          {
 219   1        Single_WriteI2C(PWR_MGMT_1, 0x00);  //解除休眠状态
 220   1        Single_WriteI2C(SMPLRT_DIV, 0x07);
 221   1        Single_WriteI2C(CONFIG, 0x06);
 222   1        Single_WriteI2C(GYRO_CONFIG, 0x18);
 223   1        Single_WriteI2C(ACCEL_CONFIG, 0x01);
 224   1      }
 225          //******************************************************************************************************
 226          //合成数据
 227          //******************************************************************************************************
 228          int GetData(uchar REG_Address)
 229          {
 230   1        uchar H,L;
 231   1        H=Single_ReadI2C(REG_Address);
 232   1        L=Single_ReadI2C(REG_Address+1);
 233   1        return ((H<<8)+L);   //合成数据
 234   1      }
 235          //******************************************************************************************************
 236          //超级终端（串口调试助手）上显示10位数据
 237          //******************************************************************************************************
 238          void Display10BitData(int value)
 239          {  uchar i;
 240   1      //  value/=64;              //转换为10位数据
C51 COMPILER V9.54   MOVE                                                                  06/26/2018 11:27:10 PAGE 5   

 241   1        lcd_printf(dis, value);     //转换数据显示
 242   1        for(i=0;i<6;i++)
 243   1        {
 244   2          SeriPushSend(dis[i]);
 245   2        }
 246   1      
 247   1        //  DisplayListChar(x,y,dis,4); //启始列，行，显示数组，显示长度
 248   1      }
 249          
 250          
 251          
 252          
 253          
 254          
 255          
 256          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    655    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
